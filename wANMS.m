function [xmin,fmin,nFeval,nRef,nExp,nIC,nOC,nShrink,iter,BestCost] = wANMS(objfnc, funId, nVar, VarMin, VarMax, maxIter, maxnFeval, tol)
%
% Adaptive Nelder-Mead Simplex Algorithm with Initial Simplex generated by Halton or Sobol distribution
% for solving the unconstrained optimization problem:
%         min f(x).
%
% It uses the improved version of adaptive parameters introduced in the following paper:
%              Fuchang Gao and Lixing Han
% "Implementing the Nelder-Mead simplex algorithm with adaptive parameters"
%  Computational Optimization and Applications, 2012, 51: 259-277.
% It also uses a population generated by Sobol or Halton Sequence to create the initial simplex
%
%  by Korhan Günel
%  coded January, 2019
%
% Inputs:
%   objfnc   : Objective function
%   nVar     : dimension of problem
%   nPop     : # of initial population
%   VarMin   : Lower bound of search space
%   VarMax   : Upper bound of search space
%   method   : It can be sobol or halton sequence
%   maxIter  : Maximum number of iteration
%   maxnFeval : Maximum number of cost function evaluation
%   tol      : Tolerance for stopping criterion
%
% Outputs:
%   xmin     : Approximate optimal solution
%   fmin     : The function value at xmin
%   nFeval   : # of function evaluations
%   nExp     : # of expansion operations
%   nIC      : # of inside contraction operations
%   nOC      : # of outside contraction operations
%   nShrink  : # of shrink operations
%   BestCost : Best cost value obtained for each iteration

objfnc = fcnchk(objfnc);
dim = nVar;
L = 50;

% % Initialize adaptive parameters
% alpha = 1;
% 
% %% Construct the initial simplex
% leapInd = randi(12);
% skipInd = randi(12);
% Q = qrandstream(method,nVar,'Leap',leapInd,'Skip',skipInd);
% Y = qrand(Q,nPop*nVar);
% fY = zeros(1,nPop*nVar);
% for i=1:nPop*nVar
%     [~, fY(i), ~, ~]  = feval(objfnc, Y(i,:), funId);
% end
% %[~,minInd] = min(fY);
% %x0 = Y(minInd,:);
% [~,I] = sort(fY);
% x0 = Y(I(1),:);
% scaleFactor = min(max(max(abs(x0)),1),10);
% 
% nFeval = nPop*nVar;
% 
% % Detect the farthest point from the vertex x0
% %D = squareform(pdist(Y));
% %[~,maxInd] = max(D(I(1),:));
% 
% 
% X = zeros(nVar+1, nVar);
% fX = zeros(1, nVar+1);
% X(1,:) = x0;
% fX(1) = fY(I(1));
% for i=2:nVar+1
%     %scaleFactor = VarMin + (VarMax - VarMin)*rand;
%     %scaleFactor = 1 + (10 - 1)*rand;
%     %X(i,:) = x0 + scaleFactor*x0;
%     X(i,:) = x0 + scaleFactor*Y(I(i),:);
%     X(i,:) =  max(X(i,:),VarMin);
%     X(i,:) = min(X(i,:),VarMax);
%     [~, fX(i), ~, ~] = feval(objfnc, X(i,:), funId);
% end
% nFeval = nFeval + nVar+1;
% % Insert the farthest point to into the set of vertices
% %X(nVar+1,:) = Y(maxInd,:);
% %fX(nVar+1) = fY(maxInd);
% [fX,I] = sort(fX);
% X = X(I,:);

% Create initial simplex
X = VarMin + (VarMax - VarMin)*rand(dim+1,nVar);
fX=zeros(1,dim+1);
for i=1:dim+1
     [~, fX(i), ~, ~] = feval(objfnc, X(i,:), funId);
end
nFeval=dim+1;
[fX,I]=sort(fX);
X=X(I,:);

%% Nelder-Mead with Weighted Means 
BestCost = zeros(1,maxIter);
nRef = 0; nExp = 0; nIC = 0; nOC = 0; nShrink = 0;
calpha = 0; cbeta = 0; cgamma1 = 0; cgamma2 = 0; cdelta = 0; 
%gcf=figure;
for iter = 1:maxIter
    
%     if max(max(abs(X(2:nVar+1,:) - X(1:nVar,:)))) <= tol
%         % Stopping criterion : Check diameter is equal or less than the tolerance value
%         break;
%     end
    
%     if nFeval > maxnFeval
%         Stopping criterion
%         break;
%     end
       
    % Centroid of the best vertices
     %w = (2*(nVar-(nVar:-1:1))+1)/(nVar^2);
     %M = mean(w.*X(1:nVar,:));
     %M = sum(w.*X(1:nVar,:))./nVar;
     maxFx = max(fX); minFx = min(fX);
     w = (maxFx - fX)/(maxFx - minFx);
     w(1) = w(1) - eps;
     w(nVar+1) = w(nVar+1) + eps;
     M = sum(w'.*X(:,1:nVar))./sum(w);
     % Initialize adaptive parameters
    %beta = 2.5 - 1/iter;
    %gamma = 0.25 + 0.5/iter;
    %delta = 0.5 + 0.25/iter;
    %alpha = 1 - 1/(1+calpha);
    alpha = 1;
    beta = 3.5 + cbeta/maxIter; %2 + 1/(1+cbeta);
%     gamma1 = 0.75 + 0.25/(1+cgamma1);
%     gamma2 = 0.5 - 0.25/(1+cgamma2);
%     delta = 0.5 + 0.25/(1+cdelta);
    
    gamma1 = 0.75 + 0.1/(1+cgamma1);
    gamma2 = 0.5 - 0.1/(1+cgamma2);
    delta = 0.5 + 0.1/(1+cdelta);
%     term = (nVar^2 - w.*(nVar-w))./(w.*(nVar-w));
    %[~,Y,~,~] = feval(objfnc, zeros(1,nVar), funId);
%     if iscolumn(term)
%         beta =  term';
%     else
%         beta = term;
%     end
    % Reflection point
    R = reflection(alpha,M,X(nVar+1,:));
    [~, fR, ~, ~] = feval(objfnc, R, funId);
    nRef = nRef+1;
    nFeval = nFeval + 1;
    if fR < fX(1)
        % Update parameter for expansion point
        E = expansion(beta,M,R);
        [~, fE, ~, ~] = feval(objfnc, E, funId);
        nFeval = nFeval + 1;
        nExp = nExp + 1;
        if fE < fR
            X(nVar+1,:) = E;
            fX(nVar+1) = fE;
            cbeta = cbeta + 1;
        else
            X(nVar+1,:) = R;
            fX(nVar+1) = fR;
            calpha= calpha + 1;
        end
    else
        if fR < fX(nVar)
            % accept reflection point
            X(nVar+1,:) = R;
            fX(nVar+1) = fR;
            calpha = calpha + 1;
        else
            if fR < fX(nVar+1)
                % Update parameter for Outside Contraction point
                OC = outsideContraction(gamma1,M,R);
                [~, fOC, ~, ~] = feval(objfnc, OC, funId);
                nFeval = nFeval + 1;
                nOC = nOC + 1;
                if fOC <= fR
                    X(nVar+1,:) = OC;
                    fX(nVar+1) = fOC;
                    cgamma1 = cgamma1 + 1;
                else
                    % Shrink
                    for i=2:nVar+1
                        % Update parameter for shrink point
                        S = shrink(delta,X(1,:),X(i,:));
                        [~, fS, ~, ~] = feval(objfnc, S, funId);
                        nFeval = nFeval + 1;
                        X(i,:) = S;
                        fX(i) = fS;
                    end
                    nShrink = nShrink + nVar;
                    cdelta = cdelta+1;
                end
            else
                % Update parameter for Inside Contraction point
                IC = insideContraction(gamma2,M,R);
                [~, fIC, ~, ~] = feval(objfnc, IC, funId);
                nFeval = nFeval + 1;
                nIC = nIC + 1;
                if fIC < fX(nVar+1)
                    X(nVar+1,:) = IC;
                    fX(nVar+1) = fIC;
                    cgamma2 = cgamma2 + 1;
                else
                    % Shrink
                    for i=2:nVar+1
                        % Update parameter for shrink point
                        S = shrink(delta,X(1,:),X(i,:));
                        [~, fS, ~, ~] = feval(objfnc, S, funId);
                        nFeval = nFeval + 1;
                        X(i,:) = S;
                        fX(i) = fS;
                    end
                    nShrink = nShrink + nVar;
                    cdelta = cdelta+1;
                end
            end
        end
    end
    [fX,I] = sort(fX);
    X = X(I,:);
    BestCost(iter) = fX(1);
    
    if (iter>L) && (BestCost(iter)== BestCost(iter-L))
        X(dim+1,:) = VarMin + (VarMax - VarMin)*rand(1,nVar);
        [~, fX(dim+1), ~, ~] =feval(objfnc, X(dim+1,:), funId);
    end
    
    [fX,I] = sort(fX);
    X = X(I,:);
    BestCost(iter) = fX(1);
    
%     if mod(iter,100)==0
%        fprintf('Iteration = %4d\t :\t Best Cost = %5.4e\n', iter, BestCost(iter));
%     end
end
xmin = X(1,:);
fmin = fX(1);